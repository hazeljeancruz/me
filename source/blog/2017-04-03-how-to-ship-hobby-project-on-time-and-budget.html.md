---
title: "To ship on time you must write shitty software"
title2: 'How to ship a software pet project, on time and budget'
title3: 'Time-tested method to ship pet projects on time: write shitty code'
title4: 'Why you must have pet projects as a software engineer'
author: "Wojciech Adam Koszek"
description: >
  If you learn and grow throught building projects on your own,
  but never complete any of them, that's a problem. Because I
  had the same problem and solved it, I share some hints which will
  help you.
maillist: >
  in which I shared how to ship a hobby project on time, and budget 
address: "Menlo Park, CA"
tags:
- "software engineering"
published: true
image: 
ads:
-
spellcheck-allow:
-
---

At work you get some pieces of infrastructure
figured out by other people; ready tools, ready scripts.
Piece of cake.
If you don't touch them, you don't understand them.
You learn when you rip software appart, and then put it all back together.
But even then some methods and functions have hidden knowledge
only original author had.
To learn how to design software, you must go through the pain
of developing everything by yourself. I think we agree here.

That's what software pet projects are for.
Here you must do everything by yourself.
There's nobody whining that what you do isn't in a plan, or that
you're using wrong technology.
You can use whatever you want. You're absolutely free.
I think that's why people love making software so much.

When you must write code, scripts, `makefiles`, add some test data by
yourself, you cross the border. When asked why he repeats his verses two
hundred fifty times, Anthony Hopkins said that something magical happens
after one hundred fifty's time.

Same is in software: you get to explore stuff which otherwise you'd not
have touched, and wouldn't understand.

When you build software by yourself, you don't have the usual constraints
which you have at work: you don't have a deadline, you don't have specs, you
don't have customers asking for features, no agile plan with stories,
sprints, points and tasks. You're your own boss. You can do whatever you
want.

You build your own development environment.
It's the best way to learn.
By making your hands dirty, you're becoming a better expert.

## Why you never finish anything

You focus on wrong things in a wrong order.
The golden rule is:

Make it work.
Make it work correctly.
Make is fast.

When you put a lot of constraints on yourself, you'll be
overwhelmed pretty quickly.
You probably have some ideas on what you want your project to be.
Maybe you want to make it great, the highest quality code, which
you'll be proud of?
That's a great goal, in my opinion.
That's a pretty shitty goal for the first version of your project.
Quality takes time, and it doesn't have to be the very first thing you worry
about.
In fact, it shouldn't be.
Make it work. Make it work fast. Refactor for the highest quality later.

Let me clarify that a bit: if you're a language purist and you're obsessed
with discussions about OOP, lambdas, operators etc. I don't know what to
tell you.

## Forget scalability

You have nothing yet.
Also you aren't goin 

## Forget testing

## Don't automate stuff unnecessarily

## Forget Continuous Integration

But many of us have problems with **shipping**.

Some people even claim you can't ship a pet project don't as a hobby.

This is bullshit and I don't understand this.

Shipping a hobby project is essential for getting a feeling of
accomplishment. If you write a software that never ships, you waste your
time and you kid yourself. That's not progress.


My claim is that this hurts you. With infinite amount of time, and infinite
amount of resources, we'd never accomplish anything. Now for hobby projects
done in your free time the biggest enemy is you, and your time organization.

You must have a decent work ethic and be a good planner to squeeze some time
for your project. In my opinion you must have a slice of time every day to
work on your stuff.

Testing eats time. At work testing is absolutely required. I like to say
unit tests have a negative development time.


Common wisdom is that if you do something two times.

## 

You should start with as little as minutes, but your
stuff will be progressing slowly

Basically your free time in front of the computer is fairly different from
the time you spend at work. We must agree on that.


